{"version":3,"file":"three-6dof.min.js","sources":["../src/index.ts","../src/uniforms.ts"],"sourcesContent":["import {\n    Object3D,\n    Material,\n    ShaderMaterial,\n    TextureLoader,\n    BackSide,\n    Mesh,\n    Points,\n    SphereBufferGeometry\n} from 'three'\n\n// Load shaders\nimport frag from './shaders/sixdof.frag'\nimport vert from './shaders/sixdof.vert'\n\nimport Uniforms from './uniforms'\n\nenum TextureType {\n    TOP_BOTTOM,\n    SEPERATE\n}\n\nenum MeshDensity {\n    LOW = 64,\n    MEDIUM = 128,\n    HIGH = 256,\n    EXTRA_HIGH = 512\n}\n\nenum Style {\n    WIRE,\n    POINTS,\n    MESH\n}\n\nclass Viewer extends Object3D {\n    public props: object\n    protected loader: TextureLoader = new TextureLoader()\n    protected obj: Object3D\n    protected geometry: SphereBufferGeometry\n    protected material: Material = new ShaderMaterial({\n        uniforms: Uniforms,\n        vertexShader: vert,\n        fragmentShader: frag,\n        transparent: true,\n        side: BackSide\n    })\n\n    constructor(\n        texturePath: string = undefined,\n        depthPath?: string,\n        textureType: TextureType = TextureType.SEPERATE,\n        meshDensity: MeshDensity = MeshDensity.EXTRA_HIGH,\n        style: Style = Style.MESH,\n        displacement: number = 1\n    ) {\n        super()\n\n        if (!texturePath) throw new Error('Texture path must be defined when creating a viewer')\n\n        this.geometry = new SphereBufferGeometry(10, meshDensity, meshDensity)\n\n        if (textureType === TextureType.SEPERATE) {\n            if (!depthPath) throw new Error('When using seperate textures you must provide a depth texture as well')\n\n            // Inform the shader we are providing two seperate textures\n            this.material.uniforms.isSeperate.value = true\n\n            // Load the depth map\n            this.load(depthPath)\n                .then(texture => {\n                    this.material.uniforms.depthMap.value = texture\n                })\n                .catch(err => { throw new Error(err) })\n        }\n\n        // Load the texture\n        this.load(texturePath)\n            .then(texture => {\n                this.material.uniforms.map.value = texture\n            })\n            .catch(err => { throw new Error(err) })\n\n        // Create the Mesh/Points and add it to the viewer object\n        this.obj = this.createSceneObjectWithStyle(style)\n        this.add(this.obj)\n    }\n\n    protected createSceneObjectWithStyle(style: Style): Object3D {\n        switch (style) {\n            case Style.WIRE:\n                this.material.wireframe = true\n            case Style.MESH:\n                return new Mesh(this.geometry, this.material)\n            case Style.POINTS:\n                return new Points(this.geometry, this.material)\n        }\n    }\n\n    protected load(texturePath: string): Promise<string> {\n        return new Promise((resolve, reject) => {\n            this.loader.load(\n                texturePath,\n                texture => resolve(texture),\n                undefined,\n                () => reject(`Error loading texture error`)\n            )\n        })\n    }\n}\n\nexport { Viewer, TextureType }","import {\n    Vector2,\n    Vector4\n} from 'three'\n\nconst Uniforms = {\n    'map': {\n        type: 't',\n        value: null\n    },\n    'depthMap': {\n        type: 't',\n        value: null\n    },\n    'time': {\n        type: 'f',\n        value: 0.0\n    },\n    'opacity': {\n        type: 'f',\n        value: 1.0\n    },\n    'pointSize': {\n        type: 'f',\n        value: 3.0\n    },\n    'debugDepth': {\n        type: 'f',\n        value: 0.0\n    },\n    'isSeperate': {\n        type: 'b',\n        value: false\n    }\n}\n\nexport default Uniforms"],"names":["TextureType","MeshDensity","Style","Uniforms","type","value","Viewer","Object3D","constructor","texturePath","undefined","depthPath","textureType","SEPERATE","meshDensity","EXTRA_HIGH","style","MESH","props","loader","TextureLoader","obj","geometry","material","ShaderMaterial","uniforms","vertexShader","vert","fragmentShader","frag","transparent","side","BackSide","Error","SphereBufferGeometry","isSeperate","load","then","texture","_this","depthMap","err","map","this","createSceneObjectWithStyle","add","WIRE","wireframe","Mesh","POINTS","Points","Promise","resolve","reject","_this2"],"mappings":"2OAiBKA,EAKAC,EAOAC,61BCxBCC,EAAW,KACN,CACHC,KAAM,IACNC,MAAO,eAEC,CACRD,KAAM,IACNC,MAAO,WAEH,CACJD,KAAM,IACNC,MAAO,WAEA,CACPD,KAAM,IACNC,MAAO,aAEE,CACTD,KAAM,IACNC,MAAO,cAEG,CACVD,KAAM,IACNC,MAAO,cAEG,CACVD,KAAM,IACNC,OAAO,KDfVL,EAAAA,gBAAAA,mBAAAA,6BAAAA,EAAAA,kCAKAC,GAAAA,EAAAA,gBAAAA,EAAAA,uBAAAA,EAAAA,mBAAAA,EAAAA,gCAAAA,IAAAA,gBAOAC,GAAAA,EAAAA,iBAAAA,EAAAA,qBAAAA,EAAAA,kBAAAA,IAAAA,OAML,MAAMI,UAAeC,WAajBC,oBACIC,8DAAsBC,EACtBC,yCACAC,yDAA2BZ,cAAYa,SACvCC,yDAA2Bb,EAAYc,WACvCC,yDAAed,EAAMe,4BAjBlBC,kBACGC,OAAwB,IAAIC,qBAC5BC,gBACAC,qBACAC,SAAqB,IAAIC,iBAAe,CAC9CC,SAAUtB,EACVuB,aAAcC,EACdC,eAAgBC,EAChBC,aAAa,EACbC,KAAMC,cAaDvB,EAAa,MAAM,IAAIwB,MAAM,+DAE7BX,SAAW,IAAIY,uBAAqB,GAAIpB,EAAaA,GAEtDF,IAAgBZ,cAAYa,SAAU,KACjCF,EAAW,MAAM,IAAIsB,MAAM,8EAG3BV,SAASE,SAASU,WAAW9B,OAAQ,OAGrC+B,KAAKzB,GACL0B,MAAK,SAAAC,GACFC,EAAKhB,SAASE,SAASe,SAASnC,MAAQiC,YAErC,SAAAG,SAAe,IAAIR,MAAMQ,WAInCL,KAAK3B,GACL4B,MAAK,SAAAC,GACFC,EAAKhB,SAASE,SAASiB,IAAIrC,MAAQiC,YAEhC,SAAAG,SAAe,IAAIR,MAAMQ,WAG/BpB,IAAMsB,KAAKC,2BAA2B5B,QACtC6B,IAAIF,KAAKtB,KAGRuB,2BAA2B5B,UACzBA,QACCd,EAAM4C,UACFvB,SAASwB,WAAY,OACzB7C,EAAMe,YACA,IAAI+B,OAAKL,KAAKrB,SAAUqB,KAAKpB,eACnCrB,EAAM+C,cACA,IAAIC,SAAOP,KAAKrB,SAAUqB,KAAKpB,WAIxCa,KAAK3B,qBACJ,IAAI0C,SAAQ,SAACC,EAASC,GACzBC,EAAKnC,OAAOiB,KACR3B,GACA,SAAA6B,UAAWc,EAAQd,UACnB5B,GACA,kBAAM2C"}