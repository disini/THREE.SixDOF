import{Object3D as e,TextureLoader as t,ShaderMaterial as n,BackSide as r,SphereBufferGeometry as i,Mesh as a,Points as o}from"three";var s,p,v,l="#define GLSLIFY 1\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform float debugDepth;\nuniform bool isSeperate;\nuniform float opacity;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n\n    // If it's a single texture crop the uvs used to read the textures\n    vec2 depthUvs = isSeperate ? vUv : vec2(vUv.x, vUv.y * 0.5);\n    vec2 colorUvs = isSeperate ? vUv : vec2(vUv.x, (vUv.y * 0.5) + 0.5);\n\n    vec3 depth;\n\n    // @TODO This is a pretty expansive op perhaps split it into two shaders and pick one when compiling the WebGL program\n    if (isSeperate) {\n        depth = texture2D(depthMap, depthUvs).rgb;\n    } else {\n        depth = texture2D(map, depthUvs).rgb;\n    }\n    vec3 color = texture2D(map, colorUvs).rgb;\n\n    // Mix the depth and color based on debugDepth value\n    vec3 depthColorMixer = mix(color, depth , debugDepth);\n\n    // Render dat fragment\n    gl_FragColor = vec4(depthColorMixer, opacity);\n}",h="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform bool isSeperate;\nuniform float pointSize;\nuniform float displacement;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalMatrix * normal;\n    gl_PointSize = pointSize;\n\n    // Transform the vert by the depth value (per vertex in the normals direction)\n    vec3 vertPos = position;\n    vec2 depthUvs = isSeperate ? uv : vec2(uv.x, uv.y * 0.5);\n    vec4 depth;\n\n    // @TODO This is a pretty expansive op perhaps split it into two shaders and pick one when compiling the WebGL program\n    if (isSeperate) {\n        depth = texture2D(depthMap, depthUvs);\n    } else {\n        depth = texture2D(map, depthUvs);\n    }\n    vertPos += (depth.r * vNormal) * displacement;\n\n    gl_Position = projectionMatrix *\n                    modelViewMatrix *\n                    vec4(vertPos, 1.0);\n}",u={map:{type:"t",value:null},depthMap:{type:"t",value:null},time:{type:"f",value:0},opacity:{type:"f",value:1},pointSize:{type:"f",value:3},debugDepth:{type:"f",value:0},isSeperate:{type:"b",value:!1},displacement:{type:"f",value:1}};!function(e){e[e.WIRE=0]="WIRE",e[e.POINTS=1]="POINTS",e[e.MESH=2]="MESH"}(s||(s={})),function(e){e[e.LOW=64]="LOW",e[e.MEDIUM=128]="MEDIUM",e[e.HIGH=256]="HIGH",e[e.EXTRA_HIGH=512]="EXTRA_HIGH"}(p||(p={})),function(e){e[e.TOP_BOTTOM=0]="TOP_BOTTOM",e[e.SEPERATE=1]="SEPERATE"}(v||(v={}));class d extends e{constructor(){var e,a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,o=arguments.length>1?arguments[1]:void 0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:v.TOP_BOTTOM,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p.HIGH,c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:s.MESH,f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(super(),e=this,this.props=void 0,this.loader=new t,this.obj=void 0,this.geometry=void 0,this.material=new n({uniforms:u,vertexShader:h,fragmentShader:l,transparent:!0,side:r}),!a)throw new Error("Texture path must be defined when creating a viewer");if(this.geometry=new i(10,m,m),this.material.uniforms.displacement.value=f,d===v.SEPERATE){if(!o)throw new Error("When using seperate textures you must provide a depth texture as well");this.material.uniforms.isSeperate.value=!0,this.load(o).then((function(t){e.material.uniforms.depthMap.value=t})).catch((function(e){throw new Error(e)}))}else this.material.uniforms.isSeperate.value=!1;this.load(a).then((function(t){e.material.uniforms.map.value=t})).catch((function(e){throw new Error(e)})),this.obj=this.createSceneObjectWithStyle(c),this.add(this.obj)}createSceneObjectWithStyle(e){switch(e){case s.WIRE:this.material.wireframe=!0;case s.MESH:return new a(this.geometry,this.material);case s.POINTS:return new o(this.geometry,this.material)}}load(e){var t=this;return new Promise((function(n,r){t.loader.load(e,(function(e){return n(e)}),void 0,(function(){return r("Error loading texture error")}))}))}toggleDepthDebug(e){this.material.uniforms.debugDepth.value=null!=e?e:!this.material.uniforms.debugDepth.value}setDisplacement(e){this.material.uniforms.displacement.value=e}}export{p as MeshDensity,s as Style,v as TextureType,d as Viewer};
//# sourceMappingURL=three-6dof.esm.min.js.map
