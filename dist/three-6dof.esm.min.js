import{Object3D as e,ShaderMaterial as t,BackSide as r,SphereBufferGeometry as n,NearestFilter as o,LinearFilter as i,RGBFormat as s,Mesh as a,Points as p}from"three";var h,u,l,m="#define GLSLIFY 1\n\n/** Small util to get the depth texture */\nvec3 getDepth(sampler2D depth, vec2 uvs) {\n\n    /** Return the depth texture */\n    return texture2D(depth, uvs).rgb;\n}\n\n/** Small util to get the lower half of a texture (in our case the depthmap) */\nvec3 getDepthFromBottomHalf(sampler2D tex, vec2 uvs) {\n    \n    /** Chop the uvs to the lower half of the texture (i.e top-bottom) */\n    vec2 lower_half_uvs = vec2(uvs.x, uvs.y * 0.5);\n\n    /** Return the depth texture */\n    return texture2D(tex, lower_half_uvs).rgb;\n}\n\n/** Small util to get the upper half of a texture (in our case the color texture) */\nvec3 getColorFromUpperHalf(sampler2D tex, vec2 uvs) {\n    \n    /** Chop the uvs to the lower half of the texture (i.e top-bottom) */\n    vec2 upper_half_uvs = vec2(uvs.x, (uvs.y * 0.5) + 0.5);\n\n    /** Return the depth texture */\n    return texture2D(tex, upper_half_uvs).rgb;\n}\n\n// Uniforms\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float debugDepth;\nuniform float opacity;\n\n// Varyings from vertex program\nvarying vec2 vUv;\n\n// Internal\nvec3 depth;\nvec3 color;\n\nvoid main() {\n\n/** Use compiler definitions to know which method to pick */\n#ifdef TOP_BOTTOM\n    depth = getDepthFromBottomHalf(colorTexture, vUv);\n    color = getColorFromUpperHalf(colorTexture, vUv);\n#endif\n\n#ifdef SEPERATE\n    depth = getDepth(depthTexture, vUv);\n    color = texture2D(colorTexture, vUv).rgb;\n#endif\n\n    // Mix the depth and color based on debugDepth value\n    vec3 depthColorMixer = mix(color, depth , debugDepth);\n\n    // Render dat fragment\n    gl_FragColor = vec4(depthColorMixer, opacity);\n}\n",d="#define GLSLIFY 1\n\n/** Small util to get the depth texture */\nvec3 getDepth(sampler2D depth, vec2 uvs) {\n\n    /** Return the depth texture */\n    return texture2D(depth, uvs).rgb;\n}\n\n/** Small util to get the lower half of a texture (in our case the depthmap) */\nvec3 getDepthFromBottomHalf(sampler2D tex, vec2 uvs) {\n    \n    /** Chop the uvs to the lower half of the texture (i.e top-bottom) */\n    vec2 lower_half_uvs = vec2(uvs.x, uvs.y * 0.5);\n\n    /** Return the depth texture */\n    return texture2D(tex, lower_half_uvs).rgb;\n}\n\n// Uniforms\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float pointSize;\nuniform float displacement;\n\n// Varyings passed to fragment\nvarying vec2 vUv;\n\n// Internal\nfloat depth;\n\nvoid main() {\n\n    /** Transform and pass to fragment shader */\n    vUv = uv;\n\n    /** Set the GL point size for when rendering points, ignored otherwise */\n    gl_PointSize = pointSize;\n\n/** Use compiler definitions to know which method to pick */\n#ifdef TOP_BOTTOM\n    depth = getDepthFromBottomHalf(colorTexture, vUv).r;\n#endif\n\n#ifdef SEPERATE\n    depth = getDepth(depthTexture, vUv).r;\n#endif\n\n    /** \n    * Invert the normals (since they are pointing outwards) and \n    * move the position on the normal direction scaled by the \n    * displacement which is the depth for the current vertex\n    * multiplied by a `displacement` scalaer\n    **/\n    float disp = displacement * depth;\n    vec3 offset = position + (-normal) * disp;\n\n    /** Transform */\n    gl_Position = projectionMatrix *\n                    modelViewMatrix *\n                    vec4(offset, 1.0);\n}",f={colorTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},time:{type:"f",value:0},opacity:{type:"f",value:1},pointSize:{type:"f",value:3},debugDepth:{type:"f",value:0},displacement:{type:"f",value:1}};!function(e){e[e.LOW=64]="LOW",e[e.MEDIUM=128]="MEDIUM",e[e.HIGH=256]="HIGH",e[e.EXTRA_HIGH=512]="EXTRA_HIGH",e[e.EPIC=1024]="EPIC"}(h||(h={})),function(e){e[e.WIRE=0]="WIRE",e[e.POINTS=1]="POINTS",e[e.MESH=2]="MESH"}(u||(u={})),function(e){e[e.TOP_BOTTOM=0]="TOP_BOTTOM",e[e.SEPERATE=1]="SEPERATE"}(l||(l={}));class v{constructor(){this.type=l.SEPERATE,this.density=h.HIGH,this.style=u.MESH,this.displacement=4,this.radius=6}}class c extends e{constructor(e,n,o){super(),this.props=new v,this.material=new t({uniforms:f,vertexShader:d,fragmentShader:m,transparent:!0,side:r}),this.setProps(this.props,o),this.setShaderDefines(this.material,[l[this.props.type]]),c.geometry||(c.geometry=this.createSphereGeometry(this.props.radius,this.props.density)),this.assignTexture(this.props.type,e,n),this.displacement=this.props.displacement,super.add(this.createMesh(c.geometry,this.material,this.props.style))}setShaderDefines(e,t){t.forEach((function(t){return e.defines[t]=""}))}createSphereGeometry(e,t){return new n(e,t,t)}setProps(e,t){if(t)for(var r in t)e[r]?e[r]=t[r]:console.warn("THREE.SixDOF: Provided ".concat(r," in config but it is not a valid property and being ignored"))}assignTexture(e,t,r){if(e===l.SEPERATE){if(!r)throw new Error("When using seperate texture type, depthmap must be provided");this.depth=this.setDefaultTextureProps(r)}this.texture=this.setDefaultTextureProps(t)}setDefaultTextureProps(e){return e.minFilter=o,e.magFilter=i,e.format=s,e.generateMipmaps=!1,e}createMesh(e,t,r){switch(r){case u.WIRE:return this.material.wireframe||(this.material.wireframe=!0),new a(e,t);case u.MESH:return this.material.wireframe&&(this.material.wireframe=!1),new a(e,t);case u.POINTS:return new p(e,t)}}toggleDepthDebug(e){this.material.uniforms.debugDepth.value=null!=e?e:!this.material.uniforms.debugDepth.value}set displacement(e){this.material.uniforms.displacement.value=e}set depth(e){this.material.uniforms.depthTexture.value=e}set texture(e){this.material.uniforms.colorTexture.value=e}get config(){return this.props}}c.geometry=void 0;export{h as MeshDensity,u as Style,l as TextureType,c as Viewer};
//# sourceMappingURL=three-6dof.esm.min.js.map
