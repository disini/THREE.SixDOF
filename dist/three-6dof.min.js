!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e=e||self).SixDOF={},e.THREE)}(this,(function(e,t){"use strict";var r,n,i,a="#define GLSLIFY 1\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform float debugDepth;\nuniform bool isSeperate;\nuniform float opacity;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n\n    // If it's a single texture crop the uvs used to read the textures\n    vec2 depthUvs = isSeperate ? vUv : vec2(vUv.x, vUv.y * 0.5);\n    vec2 colorUvs = isSeperate ? vUv : vec2(vUv.x, (vUv.y * 0.5) + 0.5);\n\n    vec3 depth;\n\n    // @TODO This is a pretty expansive op perhaps split it into two shaders and pick one when compiling the WebGL program\n    if (isSeperate) {\n        depth = texture2D(depthMap, depthUvs).rgb;\n    } else {\n        depth = texture2D(map, depthUvs).rgb;\n    }\n    vec3 color = texture2D(map, colorUvs).rgb;\n\n    // Mix the depth and color based on debugDepth value\n    vec3 depthColorMixer = mix(color, depth , debugDepth);\n\n    // Render dat fragment\n    gl_FragColor = vec4(depthColorMixer, opacity);\n}",o="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform bool isSeperate;\nuniform float pointSize;\nuniform float displacement;\n\nfloat depthFromTexture(sampler2D tex1, sampler2D tex2, vec2 uv, bool isSeperate) {\n    \n    vec2 depthUvs = isSeperate ? uv : vec2(uv.x, uv.y * 0.5);\n\n    if (isSeperate) return texture2D(tex2, depthUvs).r;\n\n    return texture2D(tex1, depthUvs).r;\n}\n\nvoid main() {\n\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n\n    gl_PointSize = pointSize;\n\n    float depth = depthFromTexture(map, depthMap, uv, isSeperate);\n    float disp = displacement * depth;\n    vec3 offset = position + (-normal) * disp;\n\n    gl_Position = projectionMatrix *\n                    modelViewMatrix *\n                    vec4(offset, 1.0);\n}",s={map:{type:"t",value:null},depthMap:{type:"t",value:null},time:{type:"f",value:0},opacity:{type:"f",value:1},pointSize:{type:"f",value:3},debugDepth:{type:"f",value:0},isSeperate:{type:"b",value:!1},displacement:{type:"f",value:1}};(r=e.Style||(e.Style={}))[r.WIRE=0]="WIRE",r[r.POINTS=1]="POINTS",r[r.MESH=2]="MESH",(n=e.MeshDensity||(e.MeshDensity={}))[n.LOW=64]="LOW",n[n.MEDIUM=128]="MEDIUM",n[n.HIGH=256]="HIGH",n[n.EXTRA_HIGH=512]="EXTRA_HIGH",n[n.EPIC=1024]="EPIC",(i=e.TextureType||(e.TextureType={}))[i.TOP_BOTTOM=0]="TOP_BOTTOM",i[i.SEPERATE=1]="SEPERATE";class p extends t.Object3D{constructor(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,n=arguments.length>1?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.TextureType.TOP_BOTTOM,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.MeshDensity.HIGH,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e.Style.MESH,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(super(),this.props=void 0,this.loader=new t.TextureLoader,this.obj=void 0,this.geometry=void 0,this.material=new t.ShaderMaterial({uniforms:s,vertexShader:o,fragmentShader:a,transparent:!0,side:t.BackSide}),!r)throw new Error("Texture path must be defined when creating a viewer");this.createSphere(6,p),this.setTextures(r,n,i),this.setDisplacement(h),this.obj=this.createSceneObjectWithStyle(l),super.add(this.obj)}createSphere(e,r){this.geometry=new t.SphereBufferGeometry(e,r,r)}setTextures(t,r,n){var i=this;if(n===e.TextureType.SEPERATE){if(!r)throw new Error("When using seperate textures you must provide a depth texture as well");this.load(r).then((function(e){i.material.uniforms.isSeperate.value=!0,i.material.uniforms.depthMap.value=e})).catch((function(e){throw new Error(e)}))}else this.material.uniforms.isSeperate.value=!1;this.load(t).then((function(e){i.material.uniforms.map.value=e})).catch((function(e){throw new Error(e)}))}createSceneObjectWithStyle(r){switch(r){case e.Style.WIRE:this.material.wireframe=!0;case e.Style.MESH:return new t.Mesh(this.geometry,this.material);case e.Style.POINTS:return new t.Points(this.geometry,this.material)}}load(e){var t=this;return new Promise((function(r,n){t.loader.load(e,(function(e){return r(e)}),void 0,(function(){return n("Error loading texture error")}))}))}resetStyle(){this.material.wireframe=!1}toggleDepthDebug(e){this.material.uniforms.debugDepth.value=null!=e?e:!this.material.uniforms.debugDepth.value}setDisplacement(e){this.material.uniforms.displacement.value=e}setStyle(e){super.remove(this.obj),this.resetStyle(),this.obj=this.createSceneObjectWithStyle(e),super.add(this.obj)}setStyleFromString(t){super.remove(this.obj),this.resetStyle(),this.obj=this.createSceneObjectWithStyle(e.Style[t]),super.add(this.obj)}}e.Viewer=p,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=three-6dof.min.js.map
