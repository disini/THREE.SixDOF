!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e=e||self).SixDOF={},e.THREE)}(this,(function(e,t){"use strict";var r,n,i,a="#define GLSLIFY 1\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform float debugDepth;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nvoid main() {\n\n    // Mix color and depth (used for debugging)\n    vec4 depthColorMixer = mix(texture2D(map, vUv), texture2D(depthMap, vUv), debugDepth);\n    \n    gl_FragColor = depthColorMixer;\n}",o="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nuniform sampler2D map;\nuniform sampler2D depthMap;\nuniform bool isSeperate;\nuniform float pointSize;\nuniform float displacement;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalMatrix * normal;\n    gl_PointSize = pointSize;\n\n    // Transform the vert by the depth value (per vertex in the normals direction)\n    vec3 vertPos = position;\n    vertPos += (texture2D(depthMap, uv).r * vNormal) * displacement;\n\n    gl_Position = projectionMatrix *\n                    modelViewMatrix *\n                    vec4(vertPos, 1.0);\n}",u={map:{type:"t",value:null},depthMap:{type:"t",value:null},time:{type:"f",value:0},opacity:{type:"f",value:1},pointSize:{type:"f",value:3},debugDepth:{type:"f",value:0},isSeperate:{type:"b",value:!1},displacement:{type:"f",value:1}};(r=e.TextureType||(e.TextureType={}))[r.TOP_BOTTOM=0]="TOP_BOTTOM",r[r.SEPERATE=1]="SEPERATE",function(e){e[e.LOW=64]="LOW",e[e.MEDIUM=128]="MEDIUM",e[e.HIGH=256]="HIGH",e[e.EXTRA_HIGH=512]="EXTRA_HIGH"}(n||(n={})),function(e){e[e.WIRE=0]="WIRE",e[e.POINTS=1]="POINTS",e[e.MESH=2]="MESH"}(i||(i={}));class l extends t.Object3D{constructor(){var r,l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,s=arguments.length>1?arguments[1]:void 0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.TextureType.SEPERATE,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.EXTRA_HIGH,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:i.MESH,v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(super(),r=this,this.props=void 0,this.loader=new t.TextureLoader,this.obj=void 0,this.geometry=void 0,this.material=new t.ShaderMaterial({uniforms:u,vertexShader:o,fragmentShader:a,transparent:!0,side:t.BackSide}),!l)throw new Error("Texture path must be defined when creating a viewer");if(this.geometry=new t.SphereBufferGeometry(10,h,h),this.material.uniforms.displacement.value=v,p===e.TextureType.SEPERATE){if(!s)throw new Error("When using seperate textures you must provide a depth texture as well");this.material.uniforms.isSeperate.value=!0,this.load(s).then((function(e){r.material.uniforms.depthMap.value=e})).catch((function(e){throw new Error(e)}))}this.load(l).then((function(e){r.material.uniforms.map.value=e})).catch((function(e){throw new Error(e)})),this.obj=this.createSceneObjectWithStyle(d),this.add(this.obj)}createSceneObjectWithStyle(e){switch(e){case i.WIRE:this.material.wireframe=!0;case i.MESH:return new t.Mesh(this.geometry,this.material);case i.POINTS:return new t.Points(this.geometry,this.material)}}load(e){var t=this;return new Promise((function(r,n){t.loader.load(e,(function(e){return r(e)}),void 0,(function(){return n("Error loading texture error")}))}))}toggleDepthDebug(e){this.material.uniforms.debugDepth.value=null!=e?e:!this.material.uniforms.debugDepth.value}setDisplacement(e){this.material.uniforms.displacement.value=e}}e.Viewer=l,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=three-6dof.min.js.map
